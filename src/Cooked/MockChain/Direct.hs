-- | This module provides a direct (as opposed to 'Cooked.MockChain.Staged')
-- implementation of the `MonadBlockChain` specification. This rely on the
-- emulator from cardano-node-emulator for transaction validation, although we
-- have our own internal state. This choice might be revised in the future.
module Cooked.MockChain.Direct where

import Cardano.Api qualified as Cardano
import Cardano.Ledger.BaseTypes qualified as Cardano
import Cardano.Node.Emulator.Internal.Node qualified as Emulator
import Control.Applicative
import Control.Lens qualified as Lens
import Control.Monad
import Control.Monad.Except
import Control.Monad.Identity
import Control.Monad.Reader
import Control.Monad.State.Strict
import Control.Monad.Writer
import Cooked.InitialDistribution
import Cooked.MockChain.AutoReferenceScripts
import Cooked.MockChain.Balancing
import Cooked.MockChain.BlockChain
import Cooked.MockChain.GenerateTx
import Cooked.MockChain.GenerateTx.Common
import Cooked.MockChain.MinAda
import Cooked.MockChain.MockChainState
import Cooked.MockChain.UtxoState (UtxoState)
import Cooked.Pretty.Hashable
import Cooked.Skeleton
import Data.Default
import Data.Map (Map)
import Data.Map.Strict qualified as Map
import Data.Maybe (mapMaybe)
import Ledger.Index qualified as Ledger
import Ledger.Orphans ()
import Ledger.Tx qualified as Ledger
import Ledger.Tx.CardanoAPI qualified as Ledger
import Optics.Core
import Plutus.Script.Utils.Address qualified as Script
import Plutus.Script.Utils.Scripts qualified as Script
import PlutusLedgerApi.V3 qualified as Api

-- * Direct Emulation

-- $mockchaindocstr
--
-- The MockChainT monad provides a direct emulator; that is, it gives us a
-- simple way to run a full validation process directly, without relying on a
-- deployed node. While simulated, the validation is performed by the
-- cardano-ledger code, thus ensuring similar results on the real chain.
--
-- A 'MockChain':
--
-- - stores and updates a 'MockChainState'
--
-- - returns a 'UtxoState' when run
--
-- - emits entries in a 'MockChainBook'

-- | This represents elements that can be emitted throughout a 'MockChain'
-- run. These elements are either log entries corresponding to internal events
-- worth logging, or aliases for hashables corresponding to elements users
-- wishes to be properly displayed when printed with
-- 'Cooked.Pretty.Class.PrettyCooked'
data MockChainBook = MockChainBook
  { -- | Log entries generated by cooked-validators
    mcbJournal :: [MockChainLogEntry],
    -- | Aliases stored by the user
    mcbAliases :: Map Api.BuiltinByteString String
  }

instance Semigroup MockChainBook where
  MockChainBook j a <> MockChainBook j' a' = MockChainBook (j <> j') (a <> a')

instance Monoid MockChainBook where
  mempty = MockChainBook mempty mempty

-- | A 'MockChainT' builds up a stack of monads on top of a given monad @m@ to
-- reflect the requirements of the simulation. It writes a 'MockChainBook',
-- updates and reads from a 'MockChainState' and throws possible
-- 'MockChainError's.
newtype MockChainT m a = MockChainT
  {unMockChain :: (ExceptT MockChainError (StateT MockChainState (WriterT MockChainBook m))) a}
  deriving newtype
    ( Functor,
      Applicative,
      MonadState MockChainState,
      MonadError MockChainError,
      MonadWriter MockChainBook
    )

-- | Our 'MockChain' naturally instantiate the inner monad with 'Identity'
type MockChain = MockChainT Identity

-- | Custom monad instance made to increase the slot count automatically
instance (Monad m) => Monad (MockChainT m) where
  return = pure
  MockChainT x >>= f = MockChainT $ x >>= unMockChain . f

instance (Monad m) => MonadFail (MockChainT m) where
  fail = throwError . FailWith

instance MonadTrans MockChainT where
  lift = MockChainT . lift . lift . lift

instance (Monad m, Alternative m) => Alternative (MockChainT m) where
  empty = MockChainT $ ExceptT $ StateT $ const $ WriterT empty
  (<|>) = combineMockChainT (<|>)

-- | Combines two 'MockChainT' together
combineMockChainT ::
  (forall a. m a -> m a -> m a) ->
  MockChainT m x ->
  MockChainT m x ->
  MockChainT m x
combineMockChainT f ma mb = MockChainT $
  ExceptT $
    StateT $ \s ->
      let resA = runWriterT $ runStateT (runExceptT (unMockChain ma)) s
          resB = runWriterT $ runStateT (runExceptT (unMockChain mb)) s
       in WriterT $ f resA resB

-- | The returned type when running a 'MockChainT'. This is both a reorganizing
-- and filtering of the natural returned type @((Either MockChainError a,
-- MockChainState), MockChainBook)@, which is much easier to query.
data MockChainReturn a = MockChainReturn
  { -- | The returned value of the run
    mcrValue :: Either MockChainError a,
    -- | All the outputs used throughout the run
    mcrOutputs :: Map Api.TxOutRef (TxSkelOut, Bool),
    -- | The resulting 'UtxoState' of the run
    mcrUtxoState :: UtxoState,
    -- | The log entries emitted during the run
    mcrJournal :: [MockChainLogEntry],
    -- | The aliases defined during the run
    mcrAliases :: Map Api.BuiltinByteString String
  }

-- | Runs a 'MockChainT' from a default 'MockChainState'
runMockChainTRaw ::
  (Monad m) =>
  MockChainT m a ->
  m (MockChainReturn a)
runMockChainTRaw = fmap mkMockChainReturn . runWriterT . flip runStateT def . runExceptT . unMockChain
  where
    mkMockChainReturn ((val, st), MockChainBook journal aliases) =
      MockChainReturn val (mcstOutputs st) (mcstToUtxoState st) journal aliases

-- | Runs a 'MockChainT' from an initial 'MockChainState' built from a given
-- 'InitialDistribution'.
runMockChainTFrom ::
  (Monad m) =>
  InitialDistribution ->
  MockChainT m a ->
  m (MockChainReturn a)
runMockChainTFrom i0 s =
  runMockChainTRaw (mockChainState0From i0 >>= put >> s)

-- | Executes a 'MockChainT' from the canonical initial state and environment.
runMockChainT :: (Monad m) => MockChainT m a -> m (MockChainReturn a)
runMockChainT = runMockChainTFrom def

-- | See 'runMockChainTFrom'
runMockChainFrom :: InitialDistribution -> MockChain a -> MockChainReturn a
runMockChainFrom i0 = runIdentity . runMockChainTFrom i0

-- | See 'runMockChainT'
runMockChain :: MockChain a -> MockChainReturn a
runMockChain = runIdentity . runMockChainT

-- * Direct Interpretation of Operations

instance (Monad m) => MonadBlockChainBalancing (MockChainT m) where
  getParams = gets mcstParams
  txOutByRef outref = do
    res <- gets $ Map.lookup outref . mcstOutputs
    return $ case res of
      Just (txSkelOut, True) -> Just txSkelOut
      _ -> Nothing
  utxosAt (Script.toAddress -> addr) = filter ((addr ==) . txSkelOutAddress . snd) <$> allUtxos
  logEvent l = tell $ MockChainBook [l] Map.empty

instance (Monad m) => MonadBlockChainWithoutValidation (MockChainT m) where
  allUtxos =
    gets $
      mapMaybe
        (\(oRef, (txSkelOut, isAvailable)) -> if isAvailable then Just (oRef, txSkelOut) else Nothing)
        . Map.toList
        . mcstOutputs
  setParams params = do
    modify $ set mcstParamsL params
    modify $ over mcstLedgerStateL (Emulator.updateStateParams params)
  waitNSlots n = do
    cs <- gets (Emulator.getSlot . mcstLedgerState)
    if
      | n == 0 -> return cs
      | n > 0 -> do
          let newSlot = cs + fromIntegral n
          modify' (over mcstLedgerStateL $ Lens.set Emulator.elsSlotL $ fromIntegral newSlot)
          return newSlot
      | otherwise -> throwError $ MCEPastSlot cs (cs + fromIntegral n)
  define name hashable = tell (MockChainBook [] (Map.singleton (toHash hashable) name)) >> return hashable
  setConstitutionScript (Script.toVersioned -> cScript) = do
    modify' (mcstConstitutionL ?~ cScript)
    modify' $
      over mcstLedgerStateL $
        Lens.set Emulator.elsConstitutionScriptL $
          (Cardano.SJust . Cardano.toShelleyScriptHash . Script.toCardanoScriptHash)
            cScript
  getConstitutionScript = gets (view mcstConstitutionL)
  registerStakingCred (Script.toCredential -> cred) reward deposit = do
    stakeCredential <-
      throwOnToCardanoErrorOrApply
        "Unable to convert staking credential"
        Cardano.toShelleyStakeCredential
        (Ledger.toCardanoStakeCredential cred)
    modify' $
      over
        mcstLedgerStateL
        ( Emulator.registerStakeCredential
            stakeCredential
            (Cardano.Coin reward)
            (Cardano.Coin deposit)
        )

-- | Most of the logic of the direct emulation happens here
instance (Monad m) => MonadBlockChain (MockChainT m) where
  validateTxSkel skelUnbal | TxOpts {..} <- txSkelOpts skelUnbal = do
    -- We log the submission of a new skeleton
    logEvent $ MCLogSubmittedTxSkel skelUnbal
    -- We retrieve the current parameters
    oldParams <- getParams
    -- We compute the optionally modified parameters
    let newParams = applyEmulatorParamsModification txOptEmulatorParamsModification oldParams
    -- We change the parameters for the duration of the validation process
    setParams newParams
    -- We ensure that the outputs have the required minimal amount of ada, when
    -- requested in the skeleton options
    minAdaSkelUnbal <- toTxSkelWithMinAda skelUnbal
    -- We retrieve the official constitution script
    constitution <- getConstitutionScript
    -- We attach the script to each proposal that requires it
    let minAdaSkelUnbalWithConst = over (txSkelProposalsL % traversed) (`updateConstitution` constitution) minAdaSkelUnbal
    -- We add reference scripts in the various redeemers of the skeleton, when
    -- they can be found in the index and are allowed to be auto filled
    minAdaRefScriptsSkelUnbalWithConst <- toTxSkelWithReferenceScripts minAdaSkelUnbalWithConst
    -- We balance the skeleton when requested in the skeleton option, and get
    -- the associated fee, collateral inputs and return collateral wallet
    (skel, fee, mCollaterals) <- balanceTxSkel minAdaRefScriptsSkelUnbalWithConst
    -- We log the adjusted skeleton
    logEvent $ MCLogAdjustedTxSkel skel fee mCollaterals
    -- We generate the transaction asscoiated with the skeleton, and apply on it
    -- the modifications from the skeleton options
    cardanoTx <- Ledger.CardanoEmulatorEraTx . applyRawModOnBalancedTx txOptUnsafeModTx <$> txSkelToCardanoTx skel fee mCollaterals
    -- To run transaction validation we need a minimal ledger state
    eLedgerState <- gets mcstLedgerState
    -- We finally run the emulated validation. We update our internal state
    -- based on the validation result, and throw an error if this fails. If at
    -- some point we want to allows mockchain runs with validation errors, the
    -- caller will need to catch those errors and do something with them.
    case Emulator.validateCardanoTx newParams eLedgerState cardanoTx of
      -- In case of a phase 1 error, we give back the same index
      (_, Ledger.FailPhase1 _ err) -> throwError $ MCEValidationError Ledger.Phase1 err
      (newELedgerState, Ledger.FailPhase2 _ err _) | Just (colInputs, retColWallet) <- mCollaterals -> do
        -- We update the emulated ledger state
        modify' (set mcstLedgerStateL newELedgerState)
        -- We remove the collateral utxos from our own stored outputs
        forM_ colInputs $ modify' . removeOutput
        -- We add the returned collateral to our outputs (in practice this map
        -- either contains no element, or a single one)
        forM_ (Map.toList $ Ledger.getCardanoTxProducedReturnCollateral cardanoTx) $ \(txIn, txOut) ->
          modify' $
            addOutput
              (Ledger.fromCardanoTxIn txIn)
              (retColWallet `receives` Value (Api.txOutValue . Ledger.fromCardanoTxOutToPV2TxInfoTxOut . Ledger.getTxOut $ txOut))
        -- We throw a mockchain error
        throwError $ MCEValidationError Ledger.Phase2 err
      -- In case of success, we update the index with all inputs and outputs
      -- contained in the transaction
      (newELedgerState, Ledger.Success {}) -> do
        -- We update the index with the utxos consumed and produced by the tx
        modify' (set mcstLedgerStateL newELedgerState)
        -- We retrieve the utxos created by the transaction
        let utxos = Ledger.fromCardanoTxIn . snd <$> Ledger.getCardanoTxOutRefs cardanoTx
        -- We add the news utxos to the state
        forM_ (zip utxos (txSkelOuts skel)) $ modify' . uncurry addOutput
        -- And remove the old ones
        forM_ (Map.toList $ txSkelIns skel) $ modify' . removeOutput . fst
      -- This is a theoretical unreachable case. Since we fail in Phase 2, it
      -- means the transaction involved script, and thus we must have generated
      -- collaterals.
      (_, Ledger.FailPhase2 {})
        | Nothing <- mCollaterals ->
            fail "Unreachable case when processing validation result, please report a bug at https://github.com/tweag/cooked-validators/issues"
    -- We apply a change of slot when requested in the options
    when txOptAutoSlotIncrease $ modify' (over mcstLedgerStateL Emulator.nextSlot)
    -- We return the parameters to their original state
    setParams oldParams
    -- We log the validated transaction
    logEvent $ MCLogNewTx (Ledger.fromCardanoTxId $ Ledger.getCardanoTxId cardanoTx) (fromIntegral $ length $ Ledger.getCardanoTxOutRefs cardanoTx)
    -- We return the validated transaction
    return cardanoTx
