{-# LANGUAGE DeriveFunctor #-}

-- | This module provides a direct (as opposed to 'Cooked.MockChain.Staged')
-- implementation of the `MonadBlockChain` specification. This rely on the
-- emulator from cardano-node-emulator for transaction validation, although we
-- have our own internal state. This choice might be revised in the future.
module Cooked.MockChain.Direct where

import Cardano.Api qualified as Cardano
import Cardano.Api.Ledger qualified as Cardano
import Cardano.Node.Emulator.Internal.Node qualified as Emulator
import Control.Applicative
import Control.Lens qualified as Lens
import Control.Monad
import Control.Monad.Except
import Control.Monad.Identity
import Control.Monad.Reader
import Control.Monad.State.Strict
import Control.Monad.Writer
import Cooked.InitialDistribution
import Cooked.MockChain.AutoReferenceScripts
import Cooked.MockChain.Balancing
import Cooked.MockChain.BlockChain
import Cooked.MockChain.GenerateTx
import Cooked.MockChain.GenerateTx.Output
import Cooked.MockChain.GenerateTx.Witness
import Cooked.MockChain.MinAda
import Cooked.MockChain.MockChainState
import Cooked.MockChain.UtxoState (UtxoState)
import Cooked.Pretty.Hashable
import Cooked.Skeleton
import Data.Default
import Data.Map (Map)
import Data.Map.Strict qualified as Map
import Data.Maybe (mapMaybe)
import Ledger.Index qualified as Ledger
import Ledger.Orphans ()
import Ledger.Tx qualified as Ledger
import Ledger.Tx.CardanoAPI qualified as Ledger
import Optics.Core
import Plutus.Script.Utils.Address qualified as Script
import Plutus.Script.Utils.Scripts qualified as Script
import PlutusLedgerApi.V3 qualified as Api

-- * Direct Emulation

-- $mockchaindocstr
--
-- The MockChainT monad provides a direct emulator; that is, it gives us a
-- simple way to run a full validation process directly, without relying on a
-- deployed node. While simulated, the validation is performed by the
-- cardano-ledger code, thus ensuring similar results on the real chain.
--
-- A 'MockChain':
--
-- - stores and updates a 'MockChainState'
--
-- - returns a 'UtxoState' when run
--
-- - emits entries in a 'MockChainBook'

-- | This represents elements that can be emitted throughout a 'MockChain'
-- run. These elements are either log entries corresponding to internal events
-- worth logging, or aliases for hashables corresponding to elements users
-- wishes to be properly displayed when printed with
-- 'Cooked.Pretty.Class.PrettyCooked'
data MockChainBook where
  MockChainBook ::
    { -- | Log entries generated by cooked-validators
      mcbJournal :: [MockChainLogEntry],
      -- | Aliases stored by the user
      mcbAliases :: Map Api.BuiltinByteString String
    } ->
    MockChainBook

instance Semigroup MockChainBook where
  MockChainBook j a <> MockChainBook j' a' = MockChainBook (j <> j') (a <> a')

instance Monoid MockChainBook where
  mempty = MockChainBook mempty mempty

-- | A 'MockChainT' builds up a stack of monads on top of a given monad @m@ to
-- reflect the requirements of the simulation. It writes a 'MockChainBook',
-- updates and reads from a 'MockChainState' and throws possible
-- 'MockChainError's.
newtype MockChainT m a = MockChainT
  {unMockChain :: (ExceptT MockChainError (StateT MockChainState (WriterT MockChainBook m))) a}
  deriving newtype
    ( Functor,
      Applicative,
      MonadState MockChainState,
      MonadError MockChainError,
      MonadWriter MockChainBook
    )

-- | Our 'MockChain' naturally instantiate the inner monad with 'Identity'
type MockChain = MockChainT Identity

-- | Custom monad instance made to increase the slot count automatically
instance (Monad m) => Monad (MockChainT m) where
  return = pure
  MockChainT x >>= f = MockChainT $ x >>= unMockChain . f

instance (Monad m) => MonadFail (MockChainT m) where
  fail = throwError . FailWith

instance MonadTrans MockChainT where
  lift = MockChainT . lift . lift . lift

instance (Monad m, Alternative m) => Alternative (MockChainT m) where
  empty = MockChainT $ ExceptT $ StateT $ const $ WriterT empty
  (<|>) = combineMockChainT (<|>)

-- | Combines two 'MockChainT' together
combineMockChainT :: (forall a. m a -> m a -> m a) -> MockChainT m x -> MockChainT m x -> MockChainT m x
combineMockChainT f ma mb = MockChainT $
  ExceptT $
    StateT $ \s ->
      let resA = runWriterT $ runStateT (runExceptT (unMockChain ma)) s
          resB = runWriterT $ runStateT (runExceptT (unMockChain mb)) s
       in WriterT $ f resA resB

-- | The returned type when running a 'MockChainT'. This is both a reorganizing
-- and filtering of the natural returned type @((Either MockChainError a,
-- MockChainState), MockChainBook)@, which is much easier to query.
data MockChainReturn a where
  MockChainReturn ::
    { -- | The value returned by the computation, or an error
      mcrValue :: Either MockChainError a,
      -- | The outputs at the end of the run
      mcrOutputs :: Map Api.TxOutRef (TxSkelOut, Bool),
      -- | The 'UtxoState' at the end of the run
      mcrUtxoState :: UtxoState,
      -- | The final journal emitted during the run
      mcrJournal :: [MockChainLogEntry],
      -- | The map of aliases defined during the run
      mcrAliases :: Map Api.BuiltinByteString String
    } ->
    MockChainReturn a
  deriving (Functor)

-- | Runs a 'MockChainT' from a default 'MockChainState'
runMockChainTRaw :: (Monad m) => MockChainT m a -> m (MockChainReturn a)
runMockChainTRaw = fmap mkMockChainReturn . runWriterT . flip runStateT def . runExceptT . unMockChain
  where
    mkMockChainReturn ((val, st), MockChainBook journal aliases) =
      MockChainReturn val (mcstOutputs st) (mcstToUtxoState st) journal aliases

-- | Runs a 'MockChainT' from an initial 'MockChainState' built from a given
-- 'InitialDistribution'.
runMockChainTFrom :: (Monad m) => InitialDistribution -> MockChainT m a -> m (MockChainReturn a)
runMockChainTFrom (InitialDistribution i0) = runMockChainTRaw . (forceOutputs i0 >>)

-- | Executes a 'MockChainT' from the canonical initial state and environment.
runMockChainT :: (Monad m) => MockChainT m a -> m (MockChainReturn a)
runMockChainT = runMockChainTFrom def

-- | See 'runMockChainTFrom'
runMockChainFrom :: InitialDistribution -> MockChain a -> MockChainReturn a
runMockChainFrom i0 = runIdentity . runMockChainTFrom i0

-- | See 'runMockChainT'
runMockChain :: MockChain a -> MockChainReturn a
runMockChain = runIdentity . runMockChainT

-- * Direct Interpretation of Operations

instance (Monad m) => MonadBlockChainBalancing (MockChainT m) where
  getParams = gets mcstParams
  txSkelOutByRef oRef = do
    res <- gets $ Map.lookup oRef . mcstOutputs
    case res of
      Just (txSkelOut, True) -> return txSkelOut
      _ -> throwError $ MCEUnknownOutRef oRef
  utxosAt (Script.toAddress -> addr) = filter ((addr ==) . view txSkelOutAddressG . snd) <$> allUtxos
  logEvent l = tell $ MockChainBook [l] Map.empty

instance (Monad m) => MonadBlockChainWithoutValidation (MockChainT m) where
  allUtxos =
    gets $
      mapMaybe
        (\(oRef, (txSkelOut, isAvailable)) -> if isAvailable then Just (oRef, txSkelOut) else Nothing)
        . Map.toList
        . mcstOutputs
  setParams params = do
    modify $ set mcstParamsL params
    modify $ over mcstLedgerStateL (Emulator.updateStateParams params)
  waitNSlots n = do
    cs <- gets (Emulator.getSlot . mcstLedgerState)
    if
      | n == 0 -> return cs
      | n > 0 -> do
          let newSlot = cs + fromIntegral n
          modify' (over mcstLedgerStateL $ Lens.set Emulator.elsSlotL $ fromIntegral newSlot)
          return newSlot
      | otherwise -> throwError $ MCEPastSlot cs (cs + fromIntegral n)
  define name hashable = tell (MockChainBook [] (Map.singleton (toHash hashable) name)) >> return hashable
  setConstitutionScript (toVScript -> cScript) = do
    modify' (mcstConstitutionL ?~ cScript)
    modify' $
      over mcstLedgerStateL $
        Lens.set Emulator.elsConstitutionScriptL $
          (Cardano.SJust . Cardano.toShelleyScriptHash . Script.toCardanoScriptHash)
            cScript
  getConstitutionScript = gets (view mcstConstitutionL)
  registerStakingCred (Script.toCredential -> cred) reward deposit = do
    stakeCredential <- toStakeCredential cred
    modify' $
      over
        mcstLedgerStateL
        ( Emulator.registerStakeCredential
            stakeCredential
            (Cardano.Coin reward)
            (Cardano.Coin deposit)
        )

-- | Most of the logic of the direct emulation happens here
instance (Monad m) => MonadBlockChain (MockChainT m) where
  validateTxSkel skelUnbal | TxSkelOpts {..} <- txSkelOpts skelUnbal = do
    -- We log the submission of a new skeleton
    logEvent $ MCLogSubmittedTxSkel skelUnbal
    -- We retrieve the current parameters
    oldParams <- getParams
    -- We compute the optionally modified parameters
    let newParams = txSkelOptModParams oldParams
    -- We change the parameters for the duration of the validation process
    setParams newParams
    -- We ensure that the outputs have the required minimal amount of ada, when
    -- requested in the skeleton options
    minAdaSkelUnbal <- toTxSkelWithMinAda skelUnbal
    -- We retrieve the official constitution script and attach it to each
    -- proposal that requires it, if it's not empty
    minAdaSkelUnbalWithConst <-
      getConstitutionScript <&> maybe minAdaSkelUnbal (flip (over (txSkelProposalsL % traversed)) minAdaSkelUnbal . autoFillConstitution)
    -- We add reference scripts in the various redeemers of the skeleton, when
    -- they can be found in the index and are allowed to be auto filled
    minAdaRefScriptsSkelUnbalWithConst <- toTxSkelWithReferenceScripts minAdaSkelUnbalWithConst
    -- We balance the skeleton when requested in the skeleton option, and get
    -- the associated fee, collateral inputs and return collateral wallet
    (skel, fee, mCollaterals) <- balanceTxSkel minAdaRefScriptsSkelUnbalWithConst
    -- We log the adjusted skeleton
    logEvent $ MCLogAdjustedTxSkel skel fee mCollaterals
    -- We generate the transaction asscoiated with the skeleton, and apply on it
    -- the modifications from the skeleton options
    cardanoTx <- Ledger.CardanoEmulatorEraTx . txSkelOptModTx <$> txSkelToCardanoTx skel fee mCollaterals
    -- To run transaction validation we need a minimal ledger state
    eLedgerState <- gets mcstLedgerState
    -- We finally run the emulated validation. We update our internal state
    -- based on the validation result, and throw an error if this fails. If at
    -- some point we want to allows mockchain runs with validation errors, the
    -- caller will need to catch those errors and do something with them.
    case Emulator.validateCardanoTx newParams eLedgerState cardanoTx of
      -- In case of a phase 1 error, we give back the same index
      (_, Ledger.FailPhase1 _ err) -> throwError $ MCEValidationError Ledger.Phase1 err
      (newELedgerState, Ledger.FailPhase2 _ err _) | Just (colInputs, retColWallet) <- mCollaterals -> do
        -- We update the emulated ledger state
        modify' (set mcstLedgerStateL newELedgerState)
        -- We remove the collateral utxos from our own stored outputs
        forM_ colInputs $ modify' . removeOutput
        -- We add the returned collateral to our outputs (in practice this map
        -- either contains no element, or a single one)
        forM_ (Map.toList $ Ledger.getCardanoTxProducedReturnCollateral cardanoTx) $ \(txIn, txOut) ->
          modify' $
            addOutput
              (Ledger.fromCardanoTxIn txIn)
              (retColWallet `receives` Value (Api.txOutValue . Ledger.fromCardanoTxOutToPV2TxInfoTxOut . Ledger.getTxOut $ txOut))
        -- We throw a mockchain error
        throwError $ MCEValidationError Ledger.Phase2 err
      -- In case of success, we update the index with all inputs and outputs
      -- contained in the transaction
      (newELedgerState, Ledger.Success {}) -> do
        -- We update the index with the utxos consumed and produced by the tx
        modify' (set mcstLedgerStateL newELedgerState)
        -- We retrieve the utxos created by the transaction
        let utxos = Ledger.fromCardanoTxIn . snd <$> Ledger.getCardanoTxOutRefs cardanoTx
        -- We add the news utxos to the state
        forM_ (zip utxos (txSkelOuts skel)) $ modify' . uncurry addOutput
        -- And remove the old ones
        forM_ (Map.toList $ txSkelIns skel) $ modify' . removeOutput . fst
      -- This is a theoretical unreachable case. Since we fail in Phase 2, it
      -- means the transaction involved script, and thus we must have generated
      -- collaterals.
      (_, Ledger.FailPhase2 {})
        | Nothing <- mCollaterals ->
            fail "Unreachable case when processing validation result, please report a bug at https://github.com/tweag/cooked-validators/issues"
    -- We apply a change of slot when requested in the options
    when txSkelOptAutoSlotIncrease $ modify' (over mcstLedgerStateL Emulator.nextSlot)
    -- We return the parameters to their original state
    setParams oldParams
    -- We log the validated transaction
    logEvent $ MCLogNewTx (Ledger.fromCardanoTxId $ Ledger.getCardanoTxId cardanoTx) (fromIntegral $ length $ Ledger.getCardanoTxOutRefs cardanoTx)
    -- We return the validated transaction
    return cardanoTx

  forceOutputs outputs = do
    -- We retrieve the protocol parameters
    params <- getParams
    -- The emulator takes for granted transactions with a single pseudo input,
    -- which we build to force transaction validation
    let inputs =
          [ ( Cardano.genesisUTxOPseudoTxIn (Emulator.pNetworkId params) $
                Cardano.GenesisUTxOKeyHash $
                  Cardano.KeyHash "23d51e91ae5adc7ae801e9de4cd54175fb7464ec2680b25686bbb194",
              Cardano.BuildTxWith $ Cardano.KeyWitness Cardano.KeyWitnessForSpending
            )
          ]
    -- We adjust the outputs for the minimal required ADA if needed
    outputsMinAda <- mapM toTxSkelOutWithMinAda outputs
    -- We transform these outputs to Cardano outputs
    outputs' <- mapM toCardanoTxOut outputsMinAda
    -- We create our transaction body, which only consists of the dummy input
    -- and the outputs to force. This create might result in an error.
    let transactionBody =
          Emulator.createTransactionBody params $
            Ledger.CardanoBuildTx
              ( Ledger.emptyTxBodyContent
                  { Cardano.txOuts = outputs',
                    Cardano.txIns = inputs
                  }
              )
    -- We retrieve the forcefully validated transaction associated with the
    -- body, handling errors in the process.
    cardanoTx <-
      Ledger.CardanoEmulatorEraTx . txSignersAndBodyToCardanoTx []
        <$> either (throwError . MCEToCardanoError "forceOutputs :") return transactionBody
    -- We need to adjust our internal state to account for the forced
    -- transaction. We beging by computing the new map of outputs.
    let outputsMap =
          Map.fromList $
            zipWith
              (\x y -> (x, (y, True)))
              (Ledger.fromCardanoTxIn . snd <$> Ledger.getCardanoTxOutRefs cardanoTx)
              outputsMinAda
    -- We update the index, which effectively receives the new utxos
    modify' (over mcstLedgerStateL $ Lens.over Emulator.elsUtxoL (Ledger.fromPlutusIndex . Ledger.insert cardanoTx . Ledger.toPlutusIndex))
    -- We update our internal map by adding the new outputs
    modify' (over mcstOutputsL (<> outputsMap))
    -- Finally, we return the created utxos
    fmap fst <$> utxosFromCardanoTx cardanoTx
