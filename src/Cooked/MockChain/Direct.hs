-- | This module provides a direct (as opposed to 'Cooked.MockChain.Staged')
-- implementation of the `MonadBlockChain` specification. This rely on the
-- emulator from cardano-node-emulator for transaction validation, although we
-- have our own internal state. This choice might be revised in the future.
module Cooked.MockChain.Direct where

import Cardano.Node.Emulator.Internal.Node qualified as Emulator
import Control.Applicative
import Control.Arrow
import Control.Monad
import Control.Monad.Except
import Control.Monad.Identity
import Control.Monad.Reader
import Control.Monad.State.Strict
import Control.Monad.Writer
import Cooked.InitialDistribution
import Cooked.MockChain.AutoReferenceScripts
import Cooked.MockChain.Balancing
import Cooked.MockChain.BlockChain
import Cooked.MockChain.GenerateTx
import Cooked.MockChain.MinAda
import Cooked.MockChain.MockChainState
import Cooked.MockChain.UtxoState
import Cooked.Output
import Cooked.Pretty.Hashable
import Cooked.Skeleton
import Data.Default
import Data.Map (Map)
import Data.Map.Strict qualified as Map
import Data.Maybe
import Ledger.Index qualified as Ledger
import Ledger.Orphans ()
import Ledger.Tx qualified as Ledger
import Ledger.Tx.CardanoAPI qualified as Ledger
import PlutusLedgerApi.V3 qualified as Api

-- * Direct Emulation

-- $mockchaindocstr
--
-- The MockChainT monad provides a direct emulator; that is, it gives us a
-- simple way to run a full validation process directly, without relying on a
-- deployed node. While simulated, the validation is performed by the
-- cardano-ledger code, thus ensuring similar results on the real chain.
--
-- A 'MockChain':
--
-- - stores and updates a 'MockChainState'
--
-- - returns a 'UtxoState' when run
--
-- - emits entries in a 'MockChainBook'

-- | This represents elements that can be emitted throughout a 'MockChain'
-- run. These elements are either log entries corresponding to internal events
-- worth logging, or aliases for hashables corresponding to elements users
-- wishes to be properly displayed when printed with
-- 'Cooked.Pretty.Class.PrettyCooked'
data MockChainBook = MockChainBook
  { -- | Log entries generated by cooked-validators
    mcbJournal :: [MockChainLogEntry],
    -- | Aliases stored by the user
    mcbAliases :: Map Api.BuiltinByteString String
  }

instance Semigroup MockChainBook where
  MockChainBook j a <> MockChainBook j' a' = MockChainBook (j <> j') (a <> a')

instance Monoid MockChainBook where
  mempty = MockChainBook mempty mempty

-- | A 'MockChainT' builds up a stack of monads on top of a given monad
-- @m@ to reflect the requirements of the simulation.
newtype MockChainT m a = MockChainT
  {unMockChain :: (StateT MockChainState (ExceptT MockChainError (WriterT MockChainBook m))) a}
  deriving newtype
    ( Functor,
      Applicative,
      MonadState MockChainState,
      MonadError MockChainError,
      MonadWriter MockChainBook
    )

-- | Our 'MockChain' naturally instantiate the inner monad with 'Identity'
type MockChain = MockChainT Identity

-- | Custom monad instance made to increase the slot count automatically
instance (Monad m) => Monad (MockChainT m) where
  return = pure
  MockChainT x >>= f = MockChainT $ x >>= unMockChain . f

instance (Monad m) => MonadFail (MockChainT m) where
  fail = throwError . FailWith

instance MonadTrans MockChainT where
  lift = MockChainT . lift . lift . lift

instance (Monad m, Alternative m) => Alternative (MockChainT m) where
  empty = MockChainT $ StateT $ const $ ExceptT $ WriterT empty
  (<|>) = combineMockChainT (<|>)

-- | Combines two 'MockChainT' together
combineMockChainT ::
  (forall a. m a -> m a -> m a) ->
  MockChainT m x ->
  MockChainT m x ->
  MockChainT m x
combineMockChainT f ma mb = MockChainT $
  StateT $ \s ->
    let resA = runWriterT $ runExceptT $ runStateT (unMockChain ma) s
        resB = runWriterT $ runExceptT $ runStateT (unMockChain mb) s
     in ExceptT $ WriterT $ f resA resB

-- | A generic return type for a 'MockChain' run
type MockChainReturn a b = (Either MockChainError (a, b), MockChainBook)

-- | Transforms a 'MockChainT' into another one
mapMockChainT ::
  (m (MockChainReturn a MockChainState) -> n (MockChainReturn b MockChainState)) ->
  MockChainT m a ->
  MockChainT n b
mapMockChainT f = MockChainT . mapStateT (mapExceptT (mapWriterT f)) . unMockChain

-- | Runs a 'MockChainT' from a default 'MockChainState'
runMockChainTRaw ::
  MockChainT m a ->
  m (MockChainReturn a MockChainState)
runMockChainTRaw = runWriterT . runExceptT . flip runStateT def . unMockChain

-- | Runs a 'MockChainT' from an initial 'MockChainState' built from a given
-- 'InitialDistribution'. Returns a 'UtxoState'.
runMockChainTFrom ::
  (Monad m) =>
  InitialDistribution ->
  MockChainT m a ->
  m (MockChainReturn a UtxoState)
runMockChainTFrom i0 s =
  first (right (second mcstToUtxoState))
    <$> runMockChainTRaw (mockChainState0From i0 >>= put >> s)

-- | Executes a 'MockChainT' from the canonical initial state and environment.
runMockChainT :: (Monad m) => MockChainT m a -> m (MockChainReturn a UtxoState)
runMockChainT = runMockChainTFrom def

-- | See 'runMockChainTFrom'
runMockChainFrom :: InitialDistribution -> MockChain a -> MockChainReturn a UtxoState
runMockChainFrom i0 = runIdentity . runMockChainTFrom i0

-- | See 'runMockChainT'
runMockChain :: MockChain a -> MockChainReturn a UtxoState
runMockChain = runIdentity . runMockChainT

-- * Direct Interpretation of Operations

instance (Monad m) => MonadBlockChainBalancing (MockChainT m) where
  getParams = gets mcstParams
  scriptFromHash sHash = gets $ Map.lookup sHash . mcstScripts
  txOutByRef outref = gets $ Map.lookup outref . getIndex . mcstIndex
  datumFromHash datumHash = gets $ (fst <$>) . Map.lookup datumHash . mcstDatums
  utxosAt addr = filter ((addr ==) . outputAddress . snd) <$> allUtxos
  logEvent l = tell $ MockChainBook [l] Map.empty

instance (Monad m) => MonadBlockChainWithoutValidation (MockChainT m) where
  allUtxos = gets $ Map.toList . getIndex . mcstIndex
  setParams newParams = modify (\st -> st {mcstParams = newParams})
  currentSlot = gets mcstCurrentSlot
  awaitSlot slot = modify' (\st -> st {mcstCurrentSlot = max slot (mcstCurrentSlot st)}) >> currentSlot
  define name hashable = tell (MockChainBook [] (Map.singleton (toHash hashable) name)) >> return hashable

-- | Most of the logic of the direct emulation happens here
instance (Monad m) => MonadBlockChain (MockChainT m) where
  validateTxSkel skelUnbal | TxOpts {..} <- txSkelOpts skelUnbal = do
    -- We retrieve the necessary logging data from the context
    outputs <- gets (getIndex . mcstIndex)
    datums <- gets (Map.map fst . mcstDatums)
    -- We log the submission of a new skeleton
    logEvent $ MCLogSubmittedTxSkel outputs datums skelUnbal
    -- We retrieve the current parameters
    oldParams <- getParams
    -- We compute the optionally modified parameters
    let newParams = applyEmulatorParamsModification txOptEmulatorParamsModification oldParams
    -- We change the parameters for the duration of the validation process
    setParams newParams
    -- We ensure that the outputs have the required minimal amount of ada, when
    -- requested in the skeleton options
    minAdaSkelUnbal <- toTxSkelWithMinAda skelUnbal
    -- We add reference scripts in the various redeemers of the skeleton, when
    -- they can be found in the index and are allowed to be auto filled
    minAdaRefScriptsSkelUnbal <- toTxSkelWithReferenceScripts minAdaSkelUnbal
    -- We balance the skeleton when requested in the skeleton option, and get
    -- the associated fee, collateral inputs and return collateral wallet
    (skel, fee, mCollaterals) <- balanceTxSkel minAdaRefScriptsSkelUnbal
    -- We log the adjusted skeleton
    logEvent $ MCLogAdjustedTxSkel outputs datums skel fee mCollaterals
    -- We generate the transaction associated with the skeleton, and apply on it
    -- the modifications from the skeleton options
    cardanoTx <- Ledger.CardanoEmulatorEraTx . applyRawModOnBalancedTx txOptUnsafeModTx <$> txSkelToCardanoTx skel fee mCollaterals
    -- To run transaction validation we need a minimal ledger state
    eLedgerState <- gets mcstToEmulatedLedgerState
    -- We finally run the emulated validation, and we only care about the
    -- validation result, as we update our own internal state
    let (_, mValidationResult) = Emulator.validateCardanoTx newParams eLedgerState cardanoTx
    -- We retrieve our current utxo index to perform modifications associated
    -- with the validated transaction.
    utxoIndex <- gets mcstIndex
    -- We create a new utxo index with an error when validation failed
    let (newUtxoIndex, valError) = case mValidationResult of
          -- In case of a phase 1 error, we give back the same index
          Ledger.FailPhase1 _ err -> (utxoIndex, Just (Ledger.Phase1, err))
          -- In case of a phase 2 error, we retrieve the collaterals (and yes,
          -- despite its name, 'insertCollateral' actually takes the collaterals
          -- away from the index)
          Ledger.FailPhase2 _ err _ -> (Ledger.insertCollateral cardanoTx utxoIndex, Just (Ledger.Phase2, err))
          -- In case of success, we update the index with all inputs and outputs
          -- contained in the transaction
          Ledger.Success {} -> (Ledger.insert cardanoTx utxoIndex, Nothing)
    case valError of
      -- When validation failed for any reason, we throw an error. TODO: This
      -- behavior could be subject to change in the future.
      Just err -> throwError (uncurry MCEValidationError err)
      -- Otherwise, we update known validators and datums.
      Nothing -> do
        -- We add the script in outputs
        forM_ (mapMaybe txSkelOutValidator (txSkelOuts skel)) $ modify' . addScript
        forM_ (mapMaybe txSkelOutReferenceScript (txSkelOuts skel)) $ modify' . addScript
        -- We remove the consumed datums
        txSkelInputDataAsHashes skel >>= (modify' . removeDatums)
        -- We add the created datums
        (modify' . addDatums) (txSkelDataInOutputs skel)
    -- Now that we have computed a new index, we can update it
    modify' (\st -> st {mcstIndex = newUtxoIndex})
    -- We apply a change of slot when requested in the options
    when txOptAutoSlotIncrease $ modify' (\st -> st {mcstCurrentSlot = mcstCurrentSlot st + 1})
    -- We return the parameters to their original state
    setParams oldParams
    -- We log the validated transaction
    logEvent $ MCLogNewTx (Ledger.fromCardanoTxId $ Ledger.getCardanoTxId cardanoTx)
    -- We return the validated transaction
    return cardanoTx
