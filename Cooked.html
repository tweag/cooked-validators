<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>Cooked</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">cooked-validators-2.0.0</span><ul class="links" id="page-menu"><li><a href="src/Cooked.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">Cooked</p></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Re-exports the entirety of the library, which is always eventually necessary
  when writing large test-suites.</p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short">module <a href="Cooked-Wallet.html">Cooked.Wallet</a></li><li class="src short">module <a href="Cooked-ValueUtils.html">Cooked.ValueUtils</a></li><li class="src short">module <a href="Cooked-Validators.html">Cooked.Validators</a></li><li class="src short">module <a href="Cooked-Tweak.html">Cooked.Tweak</a></li><li class="src short">module <a href="Cooked-Skeleton.html">Cooked.Skeleton</a></li><li class="src short">module <a href="Cooked-ShowBS.html">Cooked.ShowBS</a></li><li class="src short">module <a href="Cooked-RawUPLC.html">Cooked.RawUPLC</a></li><li class="src short">module <a href="Cooked-Pretty.html">Cooked.Pretty</a></li><li class="src short">module <a href="Cooked-Output.html">Cooked.Output</a></li><li class="src short">module <a href="Cooked-MockChain.html">Cooked.MockChain</a></li><li class="src short">module <a href="Cooked-InitialDistribution.html">Cooked.InitialDistribution</a></li><li class="src short">module <a href="Cooked-Currencies.html">Cooked.Currencies</a></li><li class="src short">module <a href="Cooked-Attack.html">Cooked.Attack</a></li><li class="src short"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/-/docs/Distribution-Compat-Prelude-Internal.html#t:Monad" title="Distribution.Compat.Prelude.Internal">Monad</a> m =&gt; <a href="#t:MonadModal">MonadModal</a> m <span class="keyword">where</span><ul class="subs"><li><span class="keyword">type</span> <a href="#t:Modification">Modification</a> m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a></li><li><a href="#v:modifyLtl">modifyLtl</a> :: <a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> (<a href="Cooked.html#t:Modification" title="Cooked">Modification</a> m) -&gt; m a -&gt; m a</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Ltl">Ltl</a> a<ul class="subs"><li>= <a href="#v:LtlTruth">LtlTruth</a></li><li>| <a href="#v:LtlFalsity">LtlFalsity</a></li><li>| <a href="#v:LtlAtom">LtlAtom</a> a</li><li>| <a href="#v:LtlOr">LtlOr</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a) (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</li><li>| <a href="#v:LtlAnd">LtlAnd</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a) (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</li><li>| <a href="#v:LtlNext">LtlNext</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</li><li>| <a href="#v:LtlUntil">LtlUntil</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a) (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</li><li>| <a href="#v:LtlRelease">LtlRelease</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a) (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</li></ul></li></ul></details></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src">module <a href="Cooked-Wallet.html">Cooked.Wallet</a></p></div><div class="top"><p class="src">module <a href="Cooked-ValueUtils.html">Cooked.ValueUtils</a></p></div><div class="top"><p class="src">module <a href="Cooked-Validators.html">Cooked.Validators</a></p></div><div class="top"><p class="src">module <a href="Cooked-Tweak.html">Cooked.Tweak</a></p></div><div class="top"><p class="src">module <a href="Cooked-Skeleton.html">Cooked.Skeleton</a></p></div><div class="top"><p class="src">module <a href="Cooked-ShowBS.html">Cooked.ShowBS</a></p></div><div class="top"><p class="src">module <a href="Cooked-RawUPLC.html">Cooked.RawUPLC</a></p></div><div class="top"><p class="src">module <a href="Cooked-Pretty.html">Cooked.Pretty</a></p></div><div class="top"><p class="src">module <a href="Cooked-Output.html">Cooked.Output</a></p></div><div class="top"><p class="src">module <a href="Cooked-MockChain.html">Cooked.MockChain</a></p></div><div class="top"><p class="src">module <a href="Cooked-InitialDistribution.html">Cooked.InitialDistribution</a></p></div><div class="top"><p class="src">module <a href="Cooked-Currencies.html">Cooked.Currencies</a></p></div><div class="top"><p class="src">module <a href="Cooked-Attack.html">Cooked.Attack</a></p></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="https://hackage.haskell.org/package/-/docs/Distribution-Compat-Prelude-Internal.html#t:Monad" title="Distribution.Compat.Prelude.Internal">Monad</a> m =&gt; <a id="t:MonadModal" class="def">MonadModal</a> m <span class="keyword">where</span> <a href="src/Cooked.Ltl.html#MonadModal" class="link">Source</a> <a href="#t:MonadModal" class="selflink">#</a></p><div class="doc"><p>Monads that allow modificaitons with LTL formulas.</p></div><div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a id="t:Modification" class="def">Modification</a> m :: <a href="https://hackage.haskell.org/package/-/docs/Data-Kind.html#t:Type" title="Data.Kind">Type</a> <a href="src/Cooked.Ltl.html#Modification" class="link">Source</a> <a href="#t:Modification" class="selflink">#</a></p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a id="v:modifyLtl" class="def">modifyLtl</a> :: <a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> (<a href="Cooked.html#t:Modification" title="Cooked">Modification</a> m) -&gt; m a -&gt; m a <a href="src/Cooked.Ltl.html#modifyLtl" class="link">Source</a> <a href="#v:modifyLtl" class="selflink">#</a></p></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:MonadModal">Instances</h4><details id="i:MonadModal" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:ic:MonadModal:MonadModal:1"></span> <a href="Cooked.html#t:MonadModal" title="Cooked">MonadModal</a> (<a href="Cooked-Ltl.html#t:Staged" title="Cooked.Ltl">Staged</a> (<a href="Cooked-Ltl.html#t:LtlOp" title="Cooked.Ltl">LtlOp</a> modification builtin))</span> <a href="src/Cooked.Ltl.html#line-304" class="link">Source</a> <a href="#t:MonadModal" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:ic:MonadModal:MonadModal:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Cooked-Ltl.html">Cooked.Ltl</a></p> <div class="subs associated-types"><p class="caption">Associated Types</p><p class="src"><span class="keyword">type</span> <a href="Cooked.html#t:Modification" title="Cooked">Modification</a> (<a href="Cooked-Ltl.html#t:Staged" title="Cooked.Ltl">Staged</a> (<a href="Cooked-Ltl.html#t:LtlOp" title="Cooked.Ltl">LtlOp</a> modification builtin)) <a href="src/Cooked.Ltl.html#Modification" class="link">Source</a> <a href="#t:Modification" class="selflink">#</a></p></div> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:modifyLtl">modifyLtl</a> :: <a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> (<a href="Cooked.html#t:Modification" title="Cooked">Modification</a> (<a href="Cooked-Ltl.html#t:Staged" title="Cooked.Ltl">Staged</a> (<a href="Cooked-Ltl.html#t:LtlOp" title="Cooked.Ltl">LtlOp</a> modification builtin))) -&gt; <a href="Cooked-Ltl.html#t:Staged" title="Cooked.Ltl">Staged</a> (<a href="Cooked-Ltl.html#t:LtlOp" title="Cooked.Ltl">LtlOp</a> modification builtin) a -&gt; <a href="Cooked-Ltl.html#t:Staged" title="Cooked.Ltl">Staged</a> (<a href="Cooked-Ltl.html#t:LtlOp" title="Cooked.Ltl">LtlOp</a> modification builtin) a <a href="src/Cooked.Ltl.html#modifyLtl" class="link">Source</a> <a href="#v:modifyLtl" class="selflink">#</a></p></div></details></td></tr></table></details></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a id="t:Ltl" class="def">Ltl</a> a <a href="src/Cooked.Ltl.html#Ltl" class="link">Source</a> <a href="#t:Ltl" class="selflink">#</a></p><div class="doc"><p>Type of LTL formulas with atomic formulas of type <code>a</code>. Think of <code>a</code> as a
 type of &quot;modifications&quot;, then a value of type <code>Ltl a</code> describes where to
 apply modifications. Since it does not make (obvious) sense to talk of a
 negated modification or of one modification (possibly in the future) to
 imply another modification, implication and negation are absent.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a id="v:LtlTruth" class="def">LtlTruth</a></td><td class="doc"><p>The &quot;do nothing&quot; modification that never fails</p></td></tr><tr><td class="src"><a id="v:LtlFalsity" class="def">LtlFalsity</a></td><td class="doc"><p>The modification that never applies (i.e. always fails)</p></td></tr><tr><td class="src"><a id="v:LtlAtom" class="def">LtlAtom</a> a</td><td class="doc"><p>The modification that applies a given atomic modification at the current time step</p></td></tr><tr><td class="src"><a id="v:LtlOr" class="def">LtlOr</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a) (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</td><td class="doc"><p>Disjunction will be interpreted in an &quot;intuitionistic&quot; way, i.e. as
 branching into the &quot;timeline&quot; where the left disjunct holds and the one
 where the right disjunct holds. In that sense, it is an exclusive or,
 as it does not introduce the branch where both disjuncts hold.</p></td></tr><tr><td class="src"><a id="v:LtlAnd" class="def">LtlAnd</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a) (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</td><td class="doc"><p>Conjunction will be interpreted as &quot;apply both
 modifications&quot;. Attention: The &quot;apply both&quot; operation will be
 user-defined for atomic modifications, so that conjunction may for
 example fail to be commutative if the operation on atomic modification is
 not commutative.</p></td></tr><tr><td class="src"><a id="v:LtlNext" class="def">LtlNext</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</td><td class="doc"><p>Assert that the given formula holds at the next time step.</p></td></tr><tr><td class="src"><a id="v:LtlUntil" class="def">LtlUntil</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a) (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</td><td class="doc"><p>Assert that the first formula holds at least until the second one begins
 to hold, which must happen eventually. The formulas
 &gt; a <code><a href="Cooked.html#v:LtlUntil" title="Cooked">LtlUntil</a></code> b
 and
 &gt; b <code><a href="Cooked.html#v:LtlOr" title="Cooked">LtlOr</a></code> (a <code><a href="Cooked.html#v:LtlAnd" title="Cooked">LtlAnd</a></code> LtlNext (a <code><a href="Cooked.html#v:LtlUntil" title="Cooked">LtlUntil</a></code> b))
 are equivalent.</p></td></tr><tr><td class="src"><a id="v:LtlRelease" class="def">LtlRelease</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a) (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</td><td class="doc"><p>Assert that the second formula has to be true up to and including the
 point when the first one becomes true; if that never happens, the second
 formula has to remain true forever. View this as dual to <code><a href="Cooked.html#v:LtlUntil" title="Cooked">LtlUntil</a></code>. The
 formulas
 &gt; a <code><a href="Cooked.html#v:LtlRelease" title="Cooked">LtlRelease</a></code> b
 and
 &gt; b <code><a href="Cooked.html#v:LtlAnd" title="Cooked">LtlAnd</a></code> (a <code><a href="Cooked.html#v:LtlOr" title="Cooked">LtlOr</a></code> LtlNext (a <code><a href="Cooked.html#v:LtlRelease" title="Cooked">LtlRelease</a></code> b))
 are equivalent.</p></td></tr></table></div><div class="subs instances"><h4 class="instances details-toggle-control details-toggle" data-details-id="i:Ltl">Instances</h4><details id="i:Ltl" open="open"><summary class="hide-when-js-enabled">Instances details</summary><table><tr><td class="src clearfix"><span class="inst-left"><span class="instance details-toggle-control details-toggle" data-details-id="i:id:Ltl:Show:1"></span> <a href="https://hackage.haskell.org/package/-/docs/Distribution-Compat-Prelude-Internal.html#t:Show" title="Distribution.Compat.Prelude.Internal">Show</a> a =&gt; <a href="https://hackage.haskell.org/package/-/docs/Distribution-Compat-Prelude-Internal.html#t:Show" title="Distribution.Compat.Prelude.Internal">Show</a> (<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a)</span> <a href="src/Cooked.Ltl.html#line-68" class="link">Source</a> <a href="#t:Ltl" class="selflink">#</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><details id="i:id:Ltl:Show:1"><summary class="hide-when-js-enabled">Instance details</summary><p>Defined in <a href="Cooked-Ltl.html">Cooked.Ltl</a></p> <div class="subs methods"><p class="caption">Methods</p><p class="src"><a href="#v:showsPrec">showsPrec</a> :: <a href="https://hackage.haskell.org/package/-/docs/Distribution-Compat-Prelude-Internal.html#t:Int" title="Distribution.Compat.Prelude.Internal">Int</a> -&gt; <a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a -&gt; <a href="https://hackage.haskell.org/package/-/docs/Distribution-Compat-Prelude-Internal.html#t:ShowS" title="Distribution.Compat.Prelude.Internal">ShowS</a> <a href="" class="link">Source</a> <a href="#v:showsPrec" class="selflink">#</a></p><p class="src"><a href="#v:show">show</a> :: <a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a -&gt; <a href="https://hackage.haskell.org/package/-/docs/Distribution-Compat-Prelude-Internal.html#t:String" title="Distribution.Compat.Prelude.Internal">String</a> <a href="" class="link">Source</a> <a href="#v:show" class="selflink">#</a></p><p class="src"><a href="#v:showList">showList</a> :: [<a href="Cooked.html#t:Ltl" title="Cooked">Ltl</a> a] -&gt; <a href="https://hackage.haskell.org/package/-/docs/Distribution-Compat-Prelude-Internal.html#t:ShowS" title="Distribution.Compat.Prelude.Internal">ShowS</a> <a href="" class="link">Source</a> <a href="#v:showList" class="selflink">#</a></p></div></details></td></tr></table></details></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.2</p></div></body></html>